





















































journal of omnifarious — livejournal






































































































?

?









































































































































                                    





























































































































































livejournal






find more


communities


rss reader




shop









                                help
                            







                                    search
                                









                                    log in



























log in




                                        join free
                                    

                                        join
                                    







                                          english
                                        
                                        (en)
                                

english (en)

русский (ru)

українська (uk)

français (fr)

português (pt)

español (es)

deutsch (de)

italiano (it)

беларуская (be)













































omnifarious
—














< no suspend reason >









readability




















                    more
                














omnifarious







                                archive
                            



                                photos
                            



                                video
                            





readability






























log in


no account?
create an account








































remember me



                                forgot password
                            




                        log in
                        














log in









qr code

























































no account?

                    create an account
                
by logging in to livejournal using a third-party service you accept livejournal's user agreement




journal of omnifarious — livejournal(recent entries)
(archive)
(friends)
(profile)
 (omnifarious' homepage)navigate: (previous 10 entries)dec. 31st, 203711:59 pm - to all of my friends a note to all of my friends or those who would friend me
could you also please friend omnifarious' openid account [omnifarious.org] by clicking here:  and put that user (who is also me) in all the same groups you put me.  if lj ever lets you use your openid identity to log into an existing journal, this may be moot. but i'm not counting on that feature ever happening.
as an aside, if you click on the  icon in omnifarious' openid account [omnifarious.org], it takes you someplace different than clicking on the hopper [omnifarious.org] does.  the  takes you to the lj user info page, and the hopper [omnifarious.org] part takes you to the homepage for the id.tags: message, spammed_entrycurrent mood:  working(28 comments | leave a comment)feb. 18th, 201707:46 pm - trump being a pawn of russia someone i know pointed me at an interesting article about 'russophobia' and the long and conflicted history of us public opinion of russia. one of the points being made was that complaining about trump being under russian influence is pretty rich given that we essentially placed yeltsin in power in russia in the 90s. either that article, or a podcast he pointed me at also expressed worry that the 'intelligence community' (who i will hereafter refer to as the 'deep state' without quotes) is taking it upon themselves to depose a democratically elected leader.
while i think the article makes for interesting and thoughtful reading, i disagree with their opinion about trump. it's not because i disagree with their facts. it's that i disagree with their conclusions.
when we meddle in other countries, i think the other countries are perfectly justified in trying to undo the effects of our meddling, and attempts to remove our ability to further meddle in the affairs of their country. this opinion forms a backbone of my dislike of our military interventions.
much the same as the citizens of the countries we try to meddle in, we have an obligation to ourselves and to each other to have our country be run by us, not some foreign government. unless we collectively make an explicit decision to turn over the reigns to a foreign government, we should do everything in our power to make that not happen.
of course, trump was democratically elected according to the rules we've adopted for elections. and a large portion (though very definitely not a majority) of the electorate voted for him. as a democracy, we cannot simply ignore their interests. but the issue of our government being under the influence of a foreign one is orthogonal, and one that must be addressed separately.
it does disturb me that our own deep state has it in for trump. it does make me skeptical of the information they provide. but in this case there appears to be a fair amount of corroboration. in general though, the way our deep state acts as our keepers rather than our servants in something that has disturbed me for a long time.
i do wonder though how many of our other leaders have had similar problems that the deep state has chosen not to reveal because it wasn't in their interests to do so. this is a whole different issue, and part of the massive problems we currently face as a nation. problems that trump is ill-equipped to solve, even if he wasn't a likely puppet of another (hostile) government.
please reply to my original post on dreamwidth.  if you don't have an account there you can log in using your livejournal account.  just login using openid and give http://<lj account name>.livejournal.com/ as your openid.  for example, for the lj user rosencrantz319 that would be http://rosencrantz319.livejournal.com/ as their openid.tags: politicscurrent location: 5819 24th ave nw, 98107current mood:  thoughtfulnov. 19th, 201211:55 am - excellent example of market failure i have an excellent a clear-cut example of the market can fail both workers and consumers in the service of owners.
target is currently facing a fairly large petition to not open until a reasonable hour on black friday so its employees can actually spend thanksgiving with family. you might think this is just a workers issue, but it isn't. many consumers have signed this petition, and the general trend of retail outlets opening earlier and earlier on black friday is anti-consumer.
and here's why. basically people show up early to make sure they can get certain gifts before they're sold out. for those people, it's very worth it to show up before the store opens to make sure they get their chosen gift.
but each store then has an incentive to open before the others. the first store that opens gets the lions share of those consumers.
but those consumers don't actually want to wake up at 3am to get to the store before it opens. they'd be much happier waking up at 6am, or even later. but because the stores are now competing with each other to open earlier, they are forced to choose between getting the gift they want or waking up extremely early to get to the store to make sure it's not out of stock.
the 'invisible hand' of the market creates a destructive cycle that's bad for everybody.
i'm not certain what a good solution to this problem is. one would hope a gentleman's agreement on a decent opening time would work. but i doubt it would. especially since front-line store employees have little input into honoring these sorts of agreements.
but the point is here that the free market creates a situation in which both consumers and employees get the short end of the stick. they both end up in a situation neither of them desire.
please reply to my original post on dreamwidth.  if you don't have an account there you can log in using your livejournal account.  just login using openid and give http://<lj account name>.livejournal.com/ as your openid.  for example, for the lj user rosencrantz319 that would be http://rosencrantz319.livejournal.com/ as their openid.tags: money, politics, societycurrent location: 424 8th ave n, 98109current mood:  contemplativejul. 5th, 201205:29 am - the plot is not the story, nor is it the most important part one interesting phenomena i've noticed recently is a tendency to categorize something (and often dismiss it) based on plot mechanic. "the hunger games" has been compared to numerous other 'many enter, one leaves, and everybody watches' stories, especially ones involving children. "limitless" gets compared to any other story involving medical intelligence enhancement and apparently "flowers for algernon" is the canonical example.
i find this sort of distressing. there is a great deal more to a movie than its plot mechanic. plot is simply the skeleton of a story, not the most important part. it's true that if the skeleton has problems it has a serious negative effect on the whole story, but a story is not its skeleton.
"the hunger games", for example, is a story about severe oppression. the games are only a symptom of that oppression. they are certainly not the defining feature of that movie.
anyway, this is just a minor rant. :-)
please reply to my original post on dreamwidth.  if you don't have an account there you can log in using your livejournal account.  just login using openid and give http://<lj account name>.livejournal.com/ as your openid.  for example, for the lj user rosencrantz319 that would be http://rosencrantz319.livejournal.com/ as their openid.tags: culture, ideas, writingcurrent location: 2464 s spencer st, 98108current mood:  annoyedapr. 24th, 201210:18 am - the free rider problem this problem exists in many more contexts than people might otherwise think of. i came to this realization recently while talking with someone about why i really did think her choice to shop around based on price was an admirable one even if i, personally didn't do it.
in that context, i'm a free rider. i reap the benefits of the people who do shop around because they create an incentive for merchants to lower prices. but i do not engage in behavior that will create those incentives myself because it's costly in terms of time and attention.
similarly, people who use technology that's closed and locked down are free riders on people who consciously make choices to not use such technology. it can be argued that almost every innovative thing we've seen on the internet in the last 10 years is a direct result of openness and a lack of concern, or even outright hostility towards the idea of 'intellectual property'. oh, it's true that individual innovators sometimes try to achieve locks. but because of people like me, that generally causes their product to not succeed as well as those who don't. and once the open product achieves critical mass, network effects and the overwhelming advantages of openness do the rest and drive the close product to the fringes of the market.
i don't think free riders are actually necessarily bad. a significant number of them can make markets inefficient. but maybe then people don't actually care about those kinds of inefficiencies. if they did, they would make different choices.
but looking at these things as a free rider problem is a really interesting perspective. and i think the idea is much more broadly applicable than it has been.
it also explains why free riders will not necessarily kill the creation of new and interesting stuff. there are many parts of the market that thrive even when there are a significant number of free riders. when something in the market changes enough that people get upset over the inefficiency created, they stop being free riders.
please reply to my original post on dreamwidth.  if you don't have an account there you can log in using your livejournal account.  just login using openid and give http://<lj account name>.livejournal.com/ as your openid.  for example, for the lj user rosencrantz319 that would be http://rosencrantz319.livejournal.com/ as their openid.tags: economics, politics, societycurrent location: 424 8th ave n, 98109current mood:  contemplativemar. 25th, 201202:59 pm - i watched "hunger games" today i went to watch the much hyped movie today. i was prepared to be revolted, and i was. not by the movie, or the story. it was well-told, powerful and moving.
i heard people chat idly about the theme appearing in other movies. i saw them smiling as they exited the theater, talking about the finer points of the plot. i saw them wearing nice clothes for an afternoon out.
in the movie i saw the people in the capitol district chatting idly about the 'contestants'. i saw them smiling and cheering over the 'victory'. i saw them wearing their nicest clothes for the occasion.
i, for a long while, couldn't tell the difference.
that book (and the movie) were written as fiction. but i'm sure the author meant it as a mirror.
do i vote for that one, or this one? meaningless choices that we chatter about endlessly, trotting out our best justifications. few brave enough to make the choice for what they want. the choices are an avoidance of risk, a choice based on fear, not on hope.
that was the choice presented to the two characters at the end of the movie. a choice they were encouraged to make based on fear. the whole system rigged for it. and they made the choice based on hope, the choice the system couldn't tolerate.
i feel like that's what our 'democracy' has degenerated to. a circus, a spectacle geared towards making each of us, individually, make a choice based on fear of what the other guy will do.
i was angry because of the movie. upset, crying. the happy people around me... i didn't understand. a whole passel of children died on the screen. horrible deaths, lives shortened needlessly in the service of the subjugation of a whole people.
it's a happy occasion. time to put on your best stuff and chat idly about it with your friends. there is no mirror. there is no tragedy. the movie has no relevance beyond entertainment. a lie to cover the unbearable truth.
i was angry, i was saddened, and i was revolted.
yeah, i know, preachy and overbearing. listen to the message for a change instead of complaining about how it's presented. i too will go back to life as usual. but even a moment of solemnity and understanding of a shared predicament might have been nice.
please reply to my original post on dreamwidth.  if you don't have an account there you can log in using your livejournal account.  just login using openid and give http://<lj account name>.livejournal.com/ as your openid.  for example, for the lj user rosencrantz319 that would be http://rosencrantz319.livejournal.com/ as their openid.tags: angst, movies, politics, review, societycurrent location: 2044 northwest market street, 98107current mood:  touchedmar. 13th, 201208:55 am - ipv6 not the peer connectivity panacea that people think ipv6 is supposed to solve all of the peer connectivity issues introduced by nat. and, on the surface, it seems to do just that by making it possible to assign a unique, globally routable ip address to every conceivable device that could possibly want one.
but this doesn't really solve the problem of peer connectivity.
my cell phone, for example, may be assigned an address by my carrier. but my carrier may be unwilling to let me have any more addresses. this means that any devices i want to connect to the internet through my cell phone will not be able to have globally routable addresses because my isp/cell carrier won't route them. and, of course, under ipv6, nobody is ever supposed to do nat.
so, peer connectivity is still restrained by network topology. the power to decide who gets to be a router decides what gets to connect. and this is broken.
imho, the solution is to have addresses assigned to things that have nothing to do with routing, and allow a routing layer on top of the network layer that can route things to those addresses regardless of the actual topology of the network. tor is an example of this sort of thing. tor is basically a routing layer on top of tcp/ip that's designed to obscure which routes any given piece of information takes.
but tor is a specific example of a larger issue. routing cannot be left ultimately controlled by anybody except network end-points. such creates failure modes both physical and political that are significantly less than the best we can do.
which is one of the biggest advantages to a protocol like cake. :-) it divorces routing from addressing and expects end-nodes to have a hand in making routing decisions.
please reply to my original post on dreamwidth.  if you don't have an account there you can log in using your livejournal account.  just login using openid and give http://<lj account name>.livejournal.com/ as your openid.  for example, for the lj user rosencrantz319 that would be http://rosencrantz319.livejournal.com/ as their openid.tags: computers, ideas, philosophy, projectscurrent location: 2237 nw 62nd st, 98107current mood:  contemplativemar. 9th, 201212:02 pm - 'religious' issue today, a comment i got really rankled me. my affection and desire for technologies that are not freedom hostile was called a 'religious issue'. this trivializes my desire, and makes it seem like someone has to 'drink the kool-aid' to think the issue is real. and that's insulting.
i find this particularly upsetting given how many people rallied to defeat sopa. do people not understand the end goal here? do you really want your technologies to decide for you which websites you're allowed to see, what you can read, what you can hear? because ignoring freedom when making technology choices is marching down that very road.
oh, those companies, they'll never do that. but, they will. maybe they don't even realize they will. but that kind of lockdown and control is so very economically attractive that companies will march there inexorably unless it's clear that's not a direction we want to go in.
and your choices affect me. whenever you make a choice against freedom, you're affecting my ability to make that choice. it is possible to make technology that works and is convenient, but doesn't rob you of your freedom. but every time you vote with your dollars against such technology, every time you decide this feature or that feature is worth giving up some of your freedom, you're encouraging companies to dangle shiny toys in exchange for your freedom. in fact, you're encouraging them to only provide the shiny toys if you (and i) give up our freedom to get them. it's like giving in to a toddler who throws tantrums.
i recognize that different people make different choices for their own reasons. and i'm fine with them making those choices. but i will not pass up any opportunity to inform them of the effect of their choice on themselves, and on me.
please reply to my original post on dreamwidth.  if you don't have an account there you can log in using your livejournal account.  just login using openid and give http://<lj account name>.livejournal.com/ as your openid.  for example, for the lj user rosencrantz319 that would be http://rosencrantz319.livejournal.com/ as their openid.tags: angst, computers, politicscurrent location: 424 8th ave n, 98109current mood:  aggravatednov. 8th, 201101:59 pm - working on a small library, what should i name it? i'm working on a small library to express computations in terms of composable trees of dependencies. these dependencies can cross thread boundaries allowing one thread to depend on a result generated in another thread. this is sort of a riff on the whole promise and future concept, but the idea is that you have chains of these with a potential fanout in the chain greater than 1. kind of like the venerable make utility in which you express what things need to be finished before starting on the particular thing you're talking about.
but i'm not sure what i should call it. maybe teleo because it encourages to express your program in terms of a teleology.
i'm writing this basically because i've encountered the same problem on at least two different projects now, and it occurs to me that it would be really good to have a well-defined standard way of launching things in other threads and waiting for the results that suggested an overall program architecture. the projects i worked on were all set to develop a huge mishmash of different techniques that wouldn't necessarily play well together or be easy to debug.
please reply to my original post on dreamwidth.  if you don't have an account there you can log in using your livejournal account.  just login using openid and give http://<lj account name>.livejournal.com/ as your openid.  for example, for the lj user rosencrantz319 that would be http://rosencrantz319.livejournal.com/ as their openid.tags: computers, ideas, programming, projectscurrent location: 5819 24th avenue nw, 98107current mood:  creativeoct. 20th, 201103:43 pm - architecture problem... i used to have a really good idea of what the architecture of a system that had to respond to multiple different possible sources of input or other reasons to do things (such as some interval of time expiring). my idea was basically to make everything purely event-driven and have big event loops at the heart of the program that dispatched events and got things done.
this solves the vexing problem of how to deal with all these asynchronous occurrences without incurring excessively complex synchronization logic. nothing gives up control to process another event until the data structures its working with are in a consistent state.
but there are two problems with this model. one is old, and one is relatively new.
the old problem is that such event-driven systems typically exhibit inversion of control, and that makes them confusing and hard to follow. there are ways to structure your program to give people a lot of hints as to what's supposed to happen next when you give up control in the middle of an important operation only to recapture it again at some later point in time in a completely different function. but it's still not the easiest thing in the world to follow.
the 'new' problem is that silicon-based cpus have not been getting especially faster recently. they've instead been getting more numerous. this is a fairly predictable result. cpus have a clock. this clock needs to stay synchronized across the entire cpu. once clock speeds exceed a certain frequency, the clock signal takes longer to propagate across the entire chip than the amount of time before the next pulse is supposed to happen. this means that in order to have an effectively faster cpu on a single chip you need to break it up into independent units that do not need to be strictly synchronized with each other. it's a state horizon problem.
but most programs are not designed to take advantage of several cpus. if you want a program that's a cohesive whole, but still gets faster as the hardware advances, you need to break it up into several threads.
it seems like maybe it would be simple to do this with a program that had multiple threads. you just have multiple event loops. but then you end up with several interesting problems. how do you decide what things happen in which event loop? what happens if you need to have data shared between things running on different event loops? you run the risk of re-introducing the synchronization issues you avoided when you added the event loops in the first place, all with the cost of inversion of control. it doesn't seem worth it.
additionally, if you have inter-thread synchronization, what happens if it takes awhile for the other thread to free up the resource you need? how do you prevent deadlocks? most event systems do allow you to treat the release of a mutex or a semaphore as an event, so you can't just fold waiting for the mutex back into the system as just another event without doing some trick like spawning a thread that waits for the mutex and writes into some sort of ipc mechanism once it's acquired.
and splitting up your program into multiple event threads is not trivial either. how do you detect and prevent the case of one thread being overworked? also, there is 'state kiting' to consider. preferably you would prefer one cpu to be handling the same modifiable state for long periods of time. you want to avoid situations where first one cpu cache, then the next have to load up the contents of a particular memory region. typically, each core will have its own cache. if for no reason other than efficient use of space, it would be good if each core had a disjoint set of memory locations in cache. and to avoid the latency of main memory access, it would be good if that set was relatively static. this means that a single event loop should be working with a fairly small and unchanging set of memory locations.
so simply having several threads, each with its own event loop seems a solution fraught with peril, and it seems like you're throwing away a lot of the advantages you went to an event driven system (with the unpleasant inversion of control side-effect) for in the first place.
so the original idea needs modification, or perhaps a completely new idea is needed.
one modification is embodied in the language erlang. erlang still has an event loop and inversion of control. you waiting for messages that come in on a queue. any other loop can add messages to any queue it knows about. these messages are roughly analogous to events. but the messages themselves convey only information that is immutable. since it is immutable, shared or not, no synchronization is required since it cannot change.
erlang also encourages the creation of many such event loops, each of which does a very small job. hopefully, no individual loop is too overloaded. modern operating systems are adept at scheduling many jobs, and so this offloads the scheduling of all of these small tasks onto the os.
i do not think erlang does overly much to solve the locality of reference problem.
another approach is the approach taken by the e programming language. it makes extensive use of a concept called a 'future' or 'promise'. this is a promise to deliver the result of some operation at some future point in time. it allows these promises to be chained, so you can build up an elaborate structure of dependencies between promises. in a sense, the programming language handles the inversion of control for you. you specify the program as if control flow were normal, but the language environment automatically launches as many concurrent requests as possible and suspends execution until the results are available.
it is possible to build a set of library-level tools in c++11 to implement this kind of thing somewhat transparently in that language.
i am unsure if there are any major tradeoffs in this approach. certainly in c++ there is a great deal of implementation complexity, and that complexity cannot be completely hidden from the user as it is in e. i wonder if that implementation complexity introduces unacceptable overhead.
i also suspect that it may be difficult to debug programs that use this sort of a model. they appear to execute sequentially, but in truth they do not. it is possible, for example, to have two outstanding promises for bytes from a file descriptor, but which order those promises will be fulfilled in will not be readily apparent from reading the code. and error conditions can crop up at strange times and propagate to non-obvious places in the control flow of your program.
i also suspect this model will not exhibit the best locality of reference semantics. there will be a tendency to frequently spawn and join threads to handle asynchronous requests. and it will not be immediately apparent to the os cpu scheduler which threads need to work with which memory objects. and this may lead to active state kiting between cpus.
also, those calls to create and destroy threads have a cost, even if that cost is fairly small, it's still likely much more expensive than acquiring an unowned mutex, and probably even more expensive than the call to wait for a file descriptor readability event or waiting for a briefly held mutex to become available.
of course, it may be possible to implement all of this without creating many threads given a sufficiently clever runtime environment that implements its own queue that folds io state and semaphore/mutex state events into a single queue. such an environment would still need a lot of help from the application programmer though to divide up the application to maximize locality of reference within a single thread.
this is a fairly long ramble, and i'm still not really sure what the best approach is.  i think i may try to set up some kind of 'smart queue'. this queue will have a priority queue of runnable tasks, and a queue of tasks that could potentially execute given a set of conditions. when a condition is met, the queue will be informed, and if that conditions enables one or more tasks to be run, these tasks will be added to the priority queue.
i envision that the primary thing on which the priority queue will be prioritized is length of time since the task was added to the 'wait for condition' list.
i can then write a c++11 library that will allow you to automatically turn any function that returns a promise into a function that uses these conditions to split up its execution. at least, if you use sufficient care in writing the function.
the conditions (since fulfilling a promise will be a possible condition) will have data associated with them. if this data involves shared mutable state, that will require a great deal of extra care.
please reply to my original post on dreamwidth.  if you don't have an account there you can log in using your livejournal account.  just login using openid and give http://<lj account name>.livejournal.com/ as your openid.  for example, for the lj user rosencrantz319 that would be http://rosencrantz319.livejournal.com/ as their openid.tags: computers, concurrency, ideas, programmingcurrent mood:  contemplativenavigate: (previous 10 entries)




























