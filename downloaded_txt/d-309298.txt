


pointless pontifications of a back seat driver — livejournal






















































































































































?

?









































































































































                                    





























































































































































livejournal






find more


communities


rss reader




shop









                                help
                            







                                    search
                                









                                    log in



























log in




                                        join free
                                    

                                        join
                                    







                                          english
                                        
                                        (en)
                                

english (en)

русский (ru)

українська (uk)

français (fr)

português (pt)

español (es)

deutsch (de)

italiano (it)

беларуская (be)













































jwboyer
—














< no suspend reason >









readability




















                    more
                














jwboyer







                                archive
                            



                                photos
                            



                                video
                            





readability






























log in


no account?
create an account








































remember me



                                forgot password
                            




                        log in
                        














log in









qr code

























































no account?

                    create an account
                
by logging in to livejournal using a third-party service you accept livejournal's user agreement








pointless pontifications of a back seat driver
[entries|archive|friends|userinfo]






jwboyer


[
userinfo
|
livejournal userinfo
]


[
archive
|
journal archive
]















flock krakow 2016
[aug. 10th, 2016|04:34 pm]
jwboyer




[tags|fedora]the annual fedora contributor's conference, flock to fedora, wrapped up last week.  from everything i've seen and heard, it was a smashing success.  the trip reports and writeups have been very detailed and helpful, so i thought i would take a slightly different perspective with mine.  i'll cover a few sessions, but most of this will be from an organizers viewpoint.however, the highlight for me was meeting three of my new team members in person (or in the case of dan, seeing him again).  my transition to the team had just completed and it was almost purely coincidence that all of us were going to be in the same place at the same time.  i appreciate the opportunity to see them, as i really value face to face time with a team.  it was a great way to start off on a good note. sessions  the kernel talk for the first time in several years, someone else gave the fedora kernel talk.  laura abbott did a fantastic job with this.  i thought she struck a good balance in using statistics to emphasize her points where needed, whereas my talks tended to be heavy on statistics for statistics sake.  the overall theme of inclusion and community during the talk was also excellent.  we need the community around the fedora kernel to grow, and laura made that point numerous times.  hopefully people watch the video when it is online and feel empowered to reach out to the kernel maintainers.  i promise they are very approachable people. ensuring abi stability in fedora dodji seketeli and sinny kumari gave a fascinating talk on abicheck and libabigail, and it's potential uses in fedora.  having done work on toolchains and elf in the distant past, i was very impressed on how they are able to present an abi difference between two package versions down to the individual .h file level and present that in a format that humans are comfortable reading.  hopefully as work continues, we'll be able to utilize this in the fedora updates process to detect inadvertent abi changes before they land on users systems.  i also think it could be useful in the modularity effort to validate that the api/abi a module claims to export is actually what is exported.  i'm definitely going to keep an eye on the work dodji and sinny are doing here. fedora council townhall and update this session was kind of a bust for it's intended purpose.  the people in the room were literally the council members, a couple of members of osas, and one or two people that i think were really just looking for a quiet room to hack in.  however, not to make it a waste, we spent most of the session discussing some flock itself among the council and osas members.  i felt this was fairly productive, but there wasn't anything firm enough to recap here.  hopefully the results of some of that discussion are posted in the not distant future. modularity i've seen langdon give his modularity talk 3 or 4 times now across various venues.  every time i watch it, i'm amazed at its ambition and relevance in today's trending software market.  the nice thing about this session is that it continues to show progress towards actually doing this every time.  this particular time around, langdon was able to show off a few demos of installing various modules (a kernel and httpd).  live demos are always fun, and this was no exception.  i think his team is doing great work, and i'm looking forward to seeing how this plays into the way we create fedora in the future.  there are a lot of details to work out and that's where the fun part will be. prd workshop i wound up, somewhat unexpectedly, moderating a prd workshop for the fedora editions.  the prds for each wg have existed for a few releases now, and some of them are woefully out of date.  it was time to refresh what each wg was aiming for, and document that.rather than dig into the existing prds and revise from there, we started off by using the kellogg logic model that matthew miller covered in his talk earlier in the day.  we started with impact.  so we listed mission and vision statements, followed by outcomes that map to those, followed by outputs that would meet the desired outcomes.  stephen gallagher started us off with server and we spent quite a bit of time getting used to the ideas and flow of the model, and then drilling down into some of the details.  workstation was next with christian schaller and alberto ruiz leading the way.ironically, the wg that needs to address their prd the most is the cloud wg and we ran short on time to really dig into it in any meaningful way.  the main thing we took away there was basically the wg is blowing itself up and doing a pivot to become the atomic wg.  that might sound drastic, but it was a direct follow on from the cloud fad that was held recently with the wg members.  what that actually means for all the involved parties is up to them and i'm curious to see the end result. organization and logistics venuei thought the venue for flock this year worked out very well.  having the conference in the hotel makes everything massively easier.  people have less transit to worry about, the organizers only have one set of staff to work with, and it generally makes for a better conference in my opinion.  i thought the facilities were great, the quality and amount of food was good, and even the wifi worked well as long as nobody used the floor outlets (... no idea).  brian did a fantastic job finding the best western for us.schedulehaving created the schedule for flock this year i'm completely biased.  however, i thought it worked out well.  there were the inevitable gripes about conflicts between sessions people wanted to attend, but it is impossible to avoid that for everyone.  i did tell the fedora engineering team that they have to write in their goals for next year to be less awesome and submit fewer interesting talks.  they could have had a mini-conference of their own, and scheduling their talks were by far the hardest part.the only concern i had from a schedule perspective is a significantly higher number of cancellations this year.  we lost 10 sessions total for a variety of reasons.  a typical year normally results in only two or three.  the organizers will need to keep an eye on this to make sure it doesn't turn into a trend, particularly when we have a growing number of submissions overall.communicationsthe flock booklets this year were great.  ryan and the design team did a superb job with them again.  the only comment i had for ryan was to eliminate the schedule from the booklet itself.  we always get requests for new sessions on the workshop days, or cancellations/changes after the print date and that makes it obsolete before the conference even starts.  he did have a fantastic way to compensate for this though, and created a schedule on the main hallway wall every morning with printed out session tags.  i thought this was brilliant and made it much easier for attendees to know what was coming next without having to bring up the sched.org page.online channels were a mixed bag this time around.  typically the bulk of the chat is done in the flock irc channels and the staff monitor those for things that might need attention.  this year, a telegram channel was created by the attendees as well.  i think the attendees liked the telegram channel, so much so that the bulk of chatter went there.  that was somewhat problematic only in that it deviated from the past and made for one more place staff had to monitor despite us saying we weren't going to do that.  the dilution wasn't severe though.  inevitably wherever the bulk of the people are is what becomes the main avenue for communication.  i would advocate for coming up with an online discussion plan well in advance of the conference next year and sticking to it. streaming wound up having something in a similar vein.  the wifi did hold up very well, but the staff didn't feel it would be sufficient to stream all the sessions.  we went for recording instead, as we did last year, and told speakers that remote attendance or speaking via streaming wasn't something we were going to do.  as is typical with any strong willed and creative community, this was ignored for the diversity panel and they went and did it anyway.  i was pleased to find out after the fact that it seemed to go well enough, and it didn't kill wifi for the whole conference.  kudos to them for getting it done, particular for such an important topic, but i don't think it would have worked for all the sessions at once.the cityi cannot stress enough how wonderful the city itself was this year.  the people of krakow were friendly and approachable, the city was beautiful, and the evening events were great.  i say that as someone that does not like boats, and i had a great time on our boat event (as i did last year after reluctantly going).the community as always, the biggest factor to making flock a success is the fedora community.  it is rewarding to see people turn up ready to interact and contribute time and again.  i'm always impressed with what people can get done there, and with the energy level they bring.  it always leaves me looking forward to next year.

link2 comments|post comment





time for an alternative
[aug. 10th, 2016|11:00 am]
jwboyer




[tags|fedora]i've been doing kernel development or maintenance for a large portion of my professional career.  it started at my previous employer and continued for the past 5 years at red hat on the fedora kernel team, the last 3 as the defacto team lead.  it has been a fantastic experience, from both technical and people perspectives.  i consider myself extremely lucky to have been a part of the fedora kernel team, both past and present incarnations of it.  which is why when career discussions came up recently, it wasn't the easiest thing to think about.i did some pondering about what i had done and what i wanted to do.  i had some great conversations with a number of people within red hat.  after a lot of discussion and thinking, i'm very happy to have joined the fedora alternative architectures team.  this team works with all of the various non-intel architectures in fedora and within red hat.  it is a fantastic group of people, and the technical content fits perfectly with my background.  i'm very excited to be able to move from one excellent team to another.  the people within red hat continue to reinforce how rare our company is.the fedora kernel team is in great hands with laura and justin.  i'm fully confident that they'll be able to continue providing a high quality kernel and kernel community for fedora.  things shouldn't really change there on a day to day basis, and i'm not really going very far so don't be surprised to see me still poking around in the kernel package.i'll still be heavily involved in fedora day-to-day as well, participating in fesco and the fedora council.  so if you need to ping me about something fedora and/or alternative architecture related, don't hesitate.

link2 comments|post comment
















when is a kernel bug not a kernel bug?
[jun. 30th, 2016|12:27 pm]
jwboyer




[tags|fedora]think of this scenario: you're sitting at your shiny fedora install and notice a kernel update is available.  you get all excited, update it through dnf or gnome software, or whatever you use, reboot and then things stop working.  "stupid kernel update why did you break my machine" you might say.  clearly it's at fault, so you dutifully file a bug against the kernel (you do that instead of just complaining, right?).  then you get told it isn't a kernel problem, and you probably think the developers are crazy.  how can a kernel update that doesn't work not be a kernel problem?this scenario happens quite often.  to be sure, a good portion of the issues people run into with kernel updates are clearly kernel bugs.  however, there is a whole set of situations where it seems that way but really it isn't.  so what is at fault?  lots of stuff.  how?  let's talk about the boot sequence a bit. booting: a primer booting a computer is a terribly hacky thing.  if you want a really deep understanding of how it works, you should probably talk to peter jones[1].  for the purposes of this discussion, we're going to skip all the weird and crufty stuff that happens before grub is started and just call it black magic.essentially there are 3 main pieces of software that are responsible for getting your machine from power-on to whatever state userspace is supposed to be in.  those are grub, the kernel, and the initramfs.  grub loads the kernel and initramfs into memory, then hands off control to the kernel.  the kernel does the remainder of the hardware and low-level subsystem init, uncompresses the initramfs and jumps into the userspace code contained within.  the initramfs bootstraps userspace as it sees fit, mounting the rootfs and switching control to that to finish up the boot sequence.  seems simple. the initramfs so what is this "initramfs"?  in technical terms, it's a weird version of a cpio archive that contains a subset of userspace binaries needed to get you to the rootfs.  i say weird because it can also have cpu microcode tacked onto the front of it, which the kernel strips off before unpacking it and applies during the early microcode update.  this is a good thing, but it's also kind of odd.the binaries contained within the initramfs are typically your init process (systemd), system libraries, kernel modules needed for your hardware (though not all of them), firmware files, udev, dbus, etc.  it's almost equivalent to the bare minimum you can get to a prompt with.  if you want to inspect the contents for yourself, the lsinitrd command is very handy.there are actually a couple of different 'flavors' of initramfs as well.  the initramfs found in the install images is a generic initramfs that has content which should work on the widest variety of machines possible, and can be used as a rescue mechanism.  it tends to be large though, which is why after an install the initramfs is switched to hostonly mode.  that means it is specific to the machine it is created on.  the tool that creates the initramfs is called dracut, and if you're interested in how it works i would suggest reading the documentation. the problems ok, so now that we have the components involved, let's get to the actual problems that look like kernel bugs but aren't. cannot mount rootfs one of the more common issues we see after an update is that the kernel cannot mount the rootfs, which results in the system panicking.  how does this happen?  actually, there are a number of different ways.  a few are:* the initramfs wasn't included in the grub config file for unknown reasons and therefore wasn't loaded.* the initramfs was corrupted on install.* the kernel command line specified in the grub config file didn't include the proper rootfs arguments.all of those happen, and none of them are the kernel's fault.  fortunately, they tend to be fairly easy to repair but it is certainly misleading to a user when they see the kernel panic. a different update breaks your kernel update we've established that the initramfs is a collection of binaries from the distro.  it's worth clarifying that these binaries are pulled into the initramfs from what is already installed on the system.  why is that important?  because it leads to the biggest source of confusion when we say the kernel isn't at fault.fedora tends to update fast and frequently across the entire package set.  we aren't really a rolling release, but even within a release our updates are somewhat of a firehose.  that leads to situations where packages can, and often do, update independently across a given timeframe.  in fact, the only time we test a package collection as a whole is around a release milestone (keep reading for more on this).  so let's look at how this plays out in terms of a kernel update.say you're happily running a kernel from the ga release.  a week goes by and you decided to update, which brings in a slew of packages, but no kernel update (rinse and repeat this n times).  finally, a kernel update is released.  the kernel is installed, and the initramfs is built from the set of binaries that are on the system at the time of the install.  then you reboot and suddenly everything is broken.in our theoretical example, let's assume there were lvm updates in the timeframe between release and your kernel update.  now, the ga kernel is using the initramfs that was generated at install time of the ga.  it continues to do so forever.  the initramfs is never regenerated automatically for a given kernel after it is created during the kernel install transaction.  that means you've been using the lvm component shipped with ga, even though a newer version is available on the rootfs.again, theoretically say that lvm update contained a bug that made it not see particular volumes, like your root volume.  when the new kernel is installed, the initramfs will suck in this new lvm with the bug.  then you reboot and suddenly lvm cannot see your root volume.  except it is never that obvious and it just looks like a kernel problem.  compounding that issue, everything works when you boot the old kernel.  why?  because the old kernel initramfs is still using the old lvm version contained within it, which doesn't have the bug.this problem isn't specific to lvm at all.  we've seen issues with lvm, mdraid, systemd, selinux, and more.  however, because of the nature of updates and the initramfs creation, it only triggers when that new kernel is booted.  this winds up taking quite a bit of time to figure out, with a lot of resistance (understandably) from users that insist it is a kernel problem. solution: ideas wanted unfortunately, we don't really have a great solution to any of these, particularly the one mentioned immediately above.  people have suggested regenerating the initramfs after every update transaction, but that actually makes the problem worse.  it takes something known to be working and suddenly introduces the possibility that it breaks.another solution that has been suggested is to keep the userspace components in the initramfs fixed, and only update to include newer firmware and modules.  this sounds somewhat appealing at first, but there are a few issues with it.  the first is that the interaction between the kernel and userspace isn't always disjoint.  in rare cases, we might actually need a newer userspace component (such as the xorg drivers) to work properly with a kernel rebase.  today that is handled via rpm requires, and fixing the initramfs contents cannot take that into account.  other times there may be changes within the userspace components themselves that mean something in the initramfs cannot interact with an update on the rootfs.  that problem also exists in the current setup as well, but switching from today's known scenarios to a completely different setup while still having that problem doesn't sound like a good idea.a more robust solution would be to stop shipping updates in the manner in which they are shipped in fedora.  namely, treat them more like "service packs" or micro-releases that could be tested as a whole.  indeed, fedora atomic host very much operates like this with a two week release cadence.  however, that isn't prevalent across all of our editions (yet).  it also means individual package maintainers are impacted in their workflow.  that might not be a bad thing in the long run, but a change of that proportion requires time, discussion, and significant planning to accomplish.  it also needs to take into account urgent security fixes.  all of that is something i think should be done, but none of it guarantees we solve these kinds of "kernel-ish" problems.so should we all despair and throw up our hands and just live with it?  i don't think so, no.  i believe the distro as a whole will eventually help here, and in the meantime hopefully posts like this provide a little more clarity around how things work and why they may be broken.  at the very least, hopefully we can use this to educate people and make the "no, this isn't a kernel problem" discussions a bit easier for everyone.[1] it should be noted that peter might not actually want to talk to you about it.  it may bring up repressed memories of kludges and he is probably busy doing other things.

linkpost comment





(no subject)
[may. 11th, 2016|02:03 pm]
jwboyer




[tags|fedora]often we get bugs reported against the fedora kernel for issues involving third party drivers.  sometimes those are virtualbox, sometimes vmware guest tools, but most often it is the nvidia driver.  we had another reported today.  i'll pause to let you read it.  go ahead, read the whole thing.  i'll wait.https://bugzilla.redhat.com/show_bug.cgi?id=1335173done?  good.  you'll notice a couple things.  first, it's closed as cantfix with a rote comment that we typically use for such bugs.  that comment, while terse, is not incorrect.  second, the reporter is, frankly, pissed off.  you know what?he has every right to be.so if the response in the bug is not incorrect, how does that line up with the assertion that the reporter's anger isn't wrong either?  i thought i'd spend some time breaking this bug down in detail to try and explain it.the crux of the reporters argument is that using the nvidia driver on fedora causes pain to fedora's users.  i'm not going to argue against that.  using the nvidia driver on fedora is very much painful.  a user can finally get it working, and then we rebase the kernel and it breaks again for them.  that isn't a good user experience at all.  we've know this for a while and there are some tentative plans to help users in this situation by defaulting to a known working kernel if they have the nvidia driver installed.  that doesn't fix the problem, but it at least reduces the element of surprise.the reporter then goes on to make some assertions that might seem plausible, but in fact aren't accurate at all.  let's look at these more closely. the claims  you do not intentionally break hardware compatibility? oh, wait, you do.we do not intentionally break anything.  as we've written about before, we rebase the kernel to pick up the bugfixes the upstream maintainers are including in those newer releases.  however, an additional benefit of those rebases is that we actively enable more new hardware by doing so.  yes, there are regressions and they are particularly prevalent if you are relying on out-of-tree drivers.  those regressions are unfortunate, but certainly not done out of malice.you do not intentionally break api/abi compatibility? oh, wait, you do.greg-kh has talked and written extensively about the fact that the upstream kernel has no stable api.  in fact, his document is included in the kernel source itself.  due to the fact that the kernel has no stable api, there is also no stable abi.  now, it should be noted that abi here is describing the abi between the kernel and modules, not the abi between the kernel and userspace.  the kernel/userspace abi is done via syscalls and that is stable and fanatically protected by the upstream kernel maintainers.  however, modules don't have that luxury and therefore when a rebase is done the abi can and does change.  include the fact that compiler versions change in fedora, which can impact abi, and it becomes evident that the reporter's claim is somewhat true.we could freeze on a kernel version and attempt to keep the api/abi stable, but that incurs a significant maintenance cost that our small team is not able to handle.  even the rhel kernel, with it's much larger user base and development team, has a limited kabi they support.  so yes, the api/abi changes with a rebase (or more rarely with a new stable update), but that is one of the consequences of doing a rebase.  it is not done with the intention of breaking anything purposefully.you do not limit user's choice in regard to running software or drivers? oh, wait, you do.fedora actually does not limit the user's choice in software.  the user is free to install the nvidia driver or whatever other software they wish to use.  google chrome, lotus notes, steam, nvidia drivers, and other software not provided by fedora has all been known to be installed and work.  there is no problem with a user choosing to do this.  it is their own computer!what the fedora kernel team cannot do is provide support for such software.  as justin mentions in the bug itself, providing such support is very difficult for us to do.  we have no access to the driver source and cannot fix bugs in the driver.  if there is a bug in the kernel itself that the driver happens to trigger, we lack a lot of context around what the driver is doing to cause.  it is simply not a tenable position.  therefore we close all such bugs as cantfix. you make sure your software is bugs free? oh, wait, you don't. this one is starting to leave reality of software in general, in that no software is ever bug free.  we do, however, attempt to ensure we don't ship with known bugs.  also, the kernel fedora ships is very close to the upstream kernel and 95% of the bugs reported are present in the upstream kernel as well.  so "your" software here is collectively the entire kernel community. you make sure you have the most stringent qa/qc process? oh, wait, you don't. i will not argue that our qa process is the most stringent.  i won't even argue that it is more stringent than some other project's.  it is, however, constantly improving.  we've had an automated testsuite in place for more than a year now to test builds as they come out of koji.  we continue to run tests on the kernel manually on a variety of machines to make sure things are not known to be broken on certain configurations.  we are constantly looking to add more to this in as automated of a fashion as we can.however, that only scales so far.  particularly in the case of the kernel, fedora relies heavily on input from actual users via our updates-testing and bodhi infrastructure.  consider this a continued plea for help testing and catching things. (paraphrased) the nouveau driver is slower, less stable, and unusable on recent nvidia hardware quite simply, there is a lot of truth to this statement particularly for accelerated graphics situations (which gnome-shell uses).  however, this is not fedora's fault or really anyone's fault.  the nouveau driver is a reverse engineered solution that is continually improving despite having very few actual developers working on it.  we've recognized this gap and there are more people assigned to nouveau now than ever before.  progress will be slow, but it is being made.  as justin mentions, support for newer nvidia cards should continue to improve in the 4.6 and 4.7 kernels now that some of the signed firmware issues are worked out. (paraphrased) fedora expects everyone to use intel gpus we have no such expectations.  intel does have more market penetration due to the on-board gpus it ships with its newer cpus, and they have a development team working on their open source driver directly upstream.  the i915 driver is held up as the ideal standard for open source gpu drivers, but it is not bug free by any means.  the radeon driver is similarly open source and typically works well but it also is not bug free.  gpu work is hard.  at least those vendors are doing it in the open, and they should be applauded for it.  that does not mean usage of their product is required.(personally, i use both intel and ati gpus in my two primary machines.) (paraphrased) fedora sabotages its kernels to make it incompatible with third party drivers. this is blatantly false.  we do not add any patches to intentionally break anything.  that would be untrue to fedora's foundations, limiting our users for no reason at all, and i would personally find it immoral.the only limitation fedora places on third party modules is under the secure boot case in order to fully support that mechanism.  they must be signed with a cert that is imported in the kernel, and we have provided documentation on how to do this or disable secure boot for those wishing to not bother with it. so now what there is no good answer here.  while i dislike the more inflammatory claims, personal attacks, and overall tone in the bug, i stand by my assertion that the reporter has every right to be angry.  they simply want to use the hardware they have purchased.  i think the anger is misdirected somewhat, but hopefully this post illustrates that there are two sides to every story and elaborates on why it isn't as simple as many make it out to be.fedora knows people want to use things that give them the best performance or user experience.  we aren't actively trying to prevent either of those.  we try and balance the needs of as many users as we can.  in this specific case, we're also looking at ways to improve the user experience without compromising fedora's stance on proprietary software.  unfortunately, there are situations where things will break and we simply cannot fix them.  please continue to tell us about them so we're aware.  perhaps with more understanding and less vitriol in the future. this post reflects the author's opinion and is not necessarily representative of the fedora project or the author's employer. 

linkpost comment
















4.4.y kernel and xfs.  sometimes being fast and first is hard
[mar. 4th, 2016|02:51 pm]
jwboyer




[tags|fedora]tldr: update xfsprogs to xfsprogs-4.3.0-1 before you update the kernel to 4.4.4 on fedora 22/23.every once in a while we get a bug report that sounds really really bad.  so bad that it makes us do a double take and start thinking about it in detail even before we complete the normal daily bug review.  today was one of those days.this morning i read a bug report that suggested the 4.4 kernel will not boot with an xfsprogs in userspace less than version 4.3.0.  that sounds pretty bad.  fedora 23 has already been rebased to the 4.4.y stable series of kernels, and it is in update-testing for fedora 22.  given that the default filesystem in server edition is xfs, that definitely caused some concern.however, thinking about it even for a moment it seemed somewhat odd.  first, typically the only userspace component involved in mounting an xfs filesystem is mount(8).  that isn't provided by the xfsprogs package.  even if that is what was broken, one would think that there would have been bug reports long before now given that fedora 23 was rebased a while ago already.  perhaps fsck might come into play too, and that's a possibility but it isn't very likely.  so it was time to dig in further.  the report linked to an upstream discussion.  here is where things started to get clearer.  i'll try and explain a bit.around the 3.15 kernel release, xfs added support for maintaining crc checksums for on-disk metadata objects.  according to the mkfs.xfs manpage:crcs enable enhanced error detection due to hardware                          issues,  whilst  the  format  changes  also improves                       crash recovery algorithms and the ability of various                          tools  to  validate  and repair metadata corruptions                          when they are found.   the  crc  algorithm  used  is                          crc32c,  so  the overhead is dependent on cpu archi‐                          tecture as some cpus have hardware  acceleration  of                          this algorithm.  typically the overhead of calculat‐                          ing and checking the crcs is not noticable in normal                          operation.yay!  more robustness and better error recovery.  fantastic.  however, features like this are rarely enabled by default when they are first released.  in fact, the addition of this necessitated bumping the version number of the xfs on-disk format to version 5.  for further caution, xfsprogs didn't start supporting this until xfsprogs-3.2.0 and didn't make it the default for mkfs.xfs until xfsprogs-3.2.3.  pretty cautious on the part of the xfs developers.  but that still leaves us trying to figure out why the report was submitted and what it means for fedora.first, the actual problem.  in the 4.4 kernel release the xfs developers started validating some additional metadata of v5 filesystems against the log.  this is fine for healthy filesystems.  however, if you had a crash and ran xfs_repair from an older xfsprogs package, it would unconditionally zero out the log and the kernel would be very confused and report corruption when you tried to mount it.  the xfsprogs-4.3 release fixed this in the xfs_repair utility.  ok, so there's validity to the 4.4 kernel needing xfsprogs-4.3, but only in certain circumstances.  namely, you have to have a v5 filesystem on disk, and you have to run xfs_repair from an older xfsprogs against it.fortunately, that isn't a super common situation.  for fedora 22, we released with xfsprogs-3.2.2.  that means any new xfs filesystems created from installation media should still be v4 and not hit this issue (prior eol fedora releases are in the same boat).  it's possible someone manually specified crc=1 when they created their f22 xfs partition, but that is a rare case.  fedora 23, on the other hand, shipped with xfsprogs-3.2.4 and should be creating v5 xfs filesystems by default.  those users would still need to run xfs_repair, which isn't a massively common thing to do.  unfortunately, it is common enough we need to do something about it.the first thing to do was get xfsprogs updated in fedora 22 and 23 (24 and rawhide are fine already).  eric sandeen, being the massively awesome human being he is, had that done before i had even fully understood the problem.  he was, in fact, so fast that he had the bodhi updates file before we even talked about what to do in the kernel package.  that isn't ideal, but it's workable.the second thing to do was to make sure the kernel package took this into account.  originally we discussed adding a requires on the appropriate xfsprogs version.  that actually isn't a great idea though.  the kernel package doesn't actually require any of the filesystem creation tools packages and it shouldn't.  users don't want to be forced to drag around xfsprogs if they aren't even using xfs filesystems, or btrfs-progs if they aren't using btrfs, etc.  so we quickly realized that we needed to use conflicts.for the 4.4.4 kernel updates in fedora 22 and fedora 23, we added the conflicts for xfsprogs < 4.3.0-1.  you may see output that looks similar to this when you dnf update:error: package kernel-core-4.4.4-301.fc23.x86_64 conflicts with xfsprogs < 4.3.0-1 provided by xfsprogs-3.2.4-1.fc23.x86_64.the solution here is to make sure you update xfsprogs first.  then your kernel update should work fine.we'd like to thank the original bug reporter and eric sandeen for their help.[edit: added tldr for people that don't like to read and/or hate my writing]

linkpost comment
















understanding the kernel release cycle
[dec. 2nd, 2015|09:14 pm]
jwboyer




[tags|fedora]a few days ago, a fedora community member was asking if there was a 4.3 kernel for f23 yet (there isn't).  when pressed for why, it turns out they were asking for someone that wanted newer support but thought a 4.4-rc3 kernel was too new.  this was surprising to me.  the assumption was being made that 4.4-rc3 was unstable or dangerous, but that 4.3 was just fine even though fedora hasn't updated the release branches with it yet.  this led me to ponder the upstream kernel release cycle a bit, and i thought i would offer some insights as to why the version number might not represent what most people think it does.first, i will start by saying that the upstream kernel development process is amazing.  the rate of change for the 4.3 kernel was around 8 patches per hour, by 1600 developers, for a total of 12,131 changes over 63 days total[1].  and that is considered a fairly calm release by kernel standards.  the fact that the community continues to churn out kernels of such quality with that rate of change is very very impressive.  there is actually quite a bit of background coordination that goes on between the subsystem maintainers, but i'm going to focus on how linus' releases are formed for the sake of simplicity for now.a kernel release is broken into a set of discrete, roughly time-based chunks.  the first chunk is the 2 week merge window.  this is the timeframe where the subsystem maintainers send the majority of the new changes for that release to linus.  he takes them in via git pull requests, grumbles about a fair number of them, refuses a few others.  most of the pull requests are dealt with in the first week, but there are always a few late ones so linus waits the two weeks and then "closes" the window.  this culminates in the first rc release being cut.from that point on, the focus for the release is fixes.  new code being taken at this point is fairly rare, but does happen in the early -rc releases.  these are cut roughly every sunday evening, making for a one week timeframe per -rc.  each -rc release tends to be smaller in new changesets than the previous, as the community becomes much more picky on what is acceptable the longer the release has gone on.  typically it gets to -rc7, but occasionally it will go to -rc8.  one week after -rc7 is released, the "final" release is cut, which maps nicely with the 63 day timeframe quoted above.now, here is where people start getting confused.  they see a "final" release and immediately assume it's stable.  it's not.  there are bugs.  lots and lots of bugs.  so why would linus release a kernel with a lot of bugs?  because finding them all is an economy of scale.  let's step back a second into the development and see why.during the development cycle, people are constantly testing things.  however, not everyone is testing the same thing.  each subsystem maintainer is often testing their own git tree for their specific subsystem.  at the same time, they've opened their subsystem trees for changes for the next version of the kernel, not the one still in -rcx state.  so they have new code coming in before the current code is even released.  this is how they sustain that massive rate of change.aside from subsystem trees, there is the linux-next tree.  this is daily merge of all the subsystem maintainer trees that have already opened up to new code on top of whatever linus has in his tree.  a number of people are continually testing linux-next, mostly through automated bots but also in vms and running fuzzers and such.  in theory and in practice, this catches bugs before they get to linus the next round.  but it is complicated because the rate of change means that if an issue is hit, it's hard to see if it's in the new new code only found in linux-next, or if it's actually in linus' tree.  determining that usually winds up being a manual process via git-bisect, but sometimes the testing bots can determine the offending commit in an automated fashion.if a bug is found, the subsystem maintainer or patch author or whomever must track which tree the bug is, whether it's a small enough fix to go into whatever -rcx state  linus' tree is in, and how to get it there.  this is very much a manual process, and often involves multiple humans.  given that humans are terrible at multitasking in general, and grow ever more cautious the later the -rcx state is, sometimes fixes are missed or simply queued for the next merge window.  that's not to say important bugs are not fixed, because clearly there are several weeks of -rcx releases where fixing is the primary concern.  however, with all the moving parts, you're never going to find all the bugs in time.in addition to the rate of change/forest of trees issue, there's also the diversity and size of the tester pool.  most of the bots test via vms.  vms are wonderful tools, but they don't test the majority of the drivers in the kernel.  the kernel developers themselves tend to have higher end laptops.  traditionally this was of the thinkpad variety and a fair number of those are still seen, but there is some variance here now which is good.  but it isn't good enough to cover all possible firmware, device, memory, and workload combinations.  there are other testers to be sure, but they only cover a tiny fraction of the end user machines.it isn't hard to see how bugs slip through, particularly in drivers or on previous generation hardware.  i wouldn't even call it a problem really.  no software project is going to cut a release with 0 bugs in it.  it simply doesn't happen.  the kernel is actually fairly high quality at release time in spite of this.  however, as i said earlier, people tend to make assumptions and think it's good enough for daily use on whatever hardware they have.  then they're surprised when it might not be.to combat this problem, we have the upstream stable trees.  these trees backport fixes from the current development kernels that also apply to the already released kernels.  hence, 4.3.1 is linus' 4.3 release, plus a number of fixes that were found "too late".  this, in my opinion, is where the bulk of the work on making a kernel usable happens.  it is also somewhat surprising when you look at it.the first stable release of a kernel, a .1 release, is actually very large.  it is often comprised of 100-200 individual changes that are being backported from the current development kernel.  that means there are 100-200 bugs immediately being fixed there.  whew, that's a lot but ok maybe expected with everything above taken into account.  except the .2 release is often also 100-200 patches.  and .3.  and often .4.  it isn't until you start getting into .5, .6, .7, etc that the patch count starts getting smaller.  by the .9 release, it's usually time to retire the whole tree (unless it's a long-term stable) and start the fun all over again.in dealing with the fedora kernel, the maintainers take all of this into account.  this is why it is very rare to see us push a 4.x.0 kernel to a stable release, and often it isn't until .2 that you see a build.  for those thinking that this article is somehow deriding the upstream kernel development process, i hope you now realize the opposite is true.  we rely heavily on upstream following through and tagging and fixing the issues it finds, either while under development or via the stable process.  we help the stable process as well by reporting back fixes if they aren't already found.so hopefully next time you're itching for a new kernel just because it's been released upstream, you'll pause and think about this.  and if you really want to help, you'll grab a rawhide kernel and pitch in by reporting any issues when you find them.  the only way to get the stable kernel releases smaller, and reduce the number of bugs still found in freshly released kernels, is to broaden the tester pool and let the upstream developers know as soon as possible.  in this way, we're all part of the upstream kernel community and we can all keep making it awesome and impressive.(4.3.y will likely be coming to f23 the first week of january.  greg-kh seems to have gone on some kind of walkabout the past few weeks so 4.3.1 hasn't been released yet.  to be honest, it's a break well deserved.  or maybe he found 4.3 to be even more buggy as usual.  who knows!)[1] https://lwn.net/articles/661978/  (of course i was going to link to lwn.net.  if you aren't already subscribed to it, you really should be.  they have amazing articles and technical content.  they make my stuff look like junk even more than it already is.  i'm kinda jealous at the energy and expertise they show in their writing.)

link1 comment|post comment
















fedora kernel exploded tree part deux: snakes and assumptions
[oct. 6th, 2015|01:13 pm]
jwboyer




[tags|fedora]a while back i wrote about some efforts to move to using an exploded source tree for the fedora kernel.  as that post details, it wasn't the greatest experience.  however, i still think an exploded tree has good utility and i didn't want to give up on the idea of it existing.  so after scraping our "switch" i decided to (slowly) work on a tool that would create such a tree automatically.  in the spirit of release-early and pray nobody dies from reading your terrible code, we now have fedkernel.  the readme file in the repo contains a high level overview of how the tool works, so i won't duplicate that here.  instead i thought i would talk about some of the process changes and decisions we made to make this possible.git all the thingsone of the positive fallouts of the previous efforts was that all of the patches we carried in fedora were nicely formatted with changelogs and authorship information.  being literally the output of git-format-patch instantly improved the patch quality.  when it came time to figure out how to generate the patches from pkg-git to apply to the exploded tree, i really wanted to keep that quality.  so i thought about how to accomplish this and then i realized there was no need to reinvent the wheel.  the git-am and git-format-patch tools existed and were exactly what i wanted.after discussing things with the rest of the team, we switched to using git-am to apply patches in the fedora kernel spec.  the mechanics of this are pretty simple: the spec unpacks the tarball (plus any -rcx patches) and uses this as the "base" commit.  stable update patches are applied as a separate commit on top of the base if it is a stable kernel.  then it walks through every patch and applies it with git-am.  this essentially enforces our patch format guidelines for us.  it does have the somewhat negative side effect of slowing down the %prep section quite a bit, but in practice it hasn't been slow enough to be a pain.  (doing a git add and git commit on the full kernel sources isn't exactly speedy, even on an ssd.)so after %prep is done, the user is left with a git tree in the working directory that has all the fedora patches as separate commits.  "but wait, isn't the job done then?", you might ask.  well, no.  we could call it good enough, but that isn't really what i or other users of an exploded tree were after.  i wanted a tree with the full upstream commit history plus our patches.  what this produces is just a blob, plus our patches.  not quite there yet but getting closer.snakesthis is where fedkernel comes in.  i needed tooling that could take the patches from this franken-tree and apply them to a real exploded git tree.  my previous scripts were written in bash, and i could have done this in bash again but i wanted to make it automated and i wanted it to talk to the fedora infrastructure.  this means it was time to learn python again.  fortunately, the upstream python community has great documentation and there are modules for pretty much anything i needed.  this makes my "bash keyboard in interactive python session" approach to the language pretty manageable and i was able to make decent progress.to get the patches out of the prepped sources, i needed to know mainly one thing.  what was the actual upstream base for this build?  that is easy enough to figure out if you can parse certain macros in kernel.spec.  the one part that proved to be somewhat difficult was for git snapshot kernels.  we name these -gity kernels, where x increases until the next -rcx release.  e.g. kernel-4.3.0-0.rc3.git1.1, kernel-4.3.0-0.rc3.git2.1, etc.  that's great for rpms, but the only place we actually documented what upstream commit we generated the snapshot from was in an rpm %changelog comment.parsing it out of there is possible, but it's a bit cumbersome and it is somewhat error prone.  the sha1sum is always recorded, but it isn't guaranteed to be the newest changelog.  other patches and changelogs can be added before the kernel is actually built.  fortunately, we use a script to generate these snapshots.  to make it trivial to figure out the  sha1sum, i modified the script to record the full commit has to a file called gitrev in pkg-git.  now fedkernel can easily read that file and use it as the base upstream revision to apply patches on top of.  yay for cheating and/or being lazy.the rest of the code deals with prepping the tree, using the git python module to do manipulations and generate patches, and applying them to the other tree.  python actually made much of this very easy to do and again i'm really glad i used that instead of bash.assumptionsso now that we modified a few things in pkg-git to make this easier, the assumptions basically fall out to be:- patches in the prepped source can be retrieved via 'git format-patch'- the upstream base revision is determinable from kernel.spec and the gitrev file.pretty simple, right?  yes.  except the code isn't complete by any means and it requires a bit more manual setup.  like having existing pkg-git and linux.git trees that it can modify which contain all the branches and proper remotes set up already.  that isn't really a huge issue, but it does mean when f24 is branched and rawhide becomes f25, we'll need to do some updates.  perhaps before then we'll have fixed the code (or some nice person will submit a pull request that does so.)i've been using the tool to generate exploded trees for the past week or so.  it seems to be working well, and i've published them at https://git.kernel.org/cgit/linux/kernel/git/jwboyer/fedora.git/ once again.  there is a history gap there as the tree fell into disrepair for a while, but it should be kept current going forward.even if the code is terrible and hacky, writing it was a good learning experience.  i hope to keep refining it and improving things in the todo over time.  if you want to pitch in, patches are always welcome.  you can email them to me, submit a pagure.io pull request, or mail the fedora kernel list as usual.

linkpost comment





a word on fedora meetings
[sep. 9th, 2015|07:01 pm]
jwboyer




[tags|fedora]a few people have noted that when i chair a fedora meeting, i seem to move quickly and remain strictly focused on the current set topic.  i discourage broader discussion on semi-related topics and tend to finish meetings faster than most.  there is a reason for this.  it is because that is how meetings are supposed to work.there are many many articles about productivity and meetings.  i am not an expert on this at all, but i do strictly follow my own set of rules for meetings derived partly from said articles but mostly from experience.  they can be summed up as so:1) the meeting better have an agenda.  if it doesn't, i'm likely to not pay attention.  the agenda should lend itself to having items decided upon and completed during said meeting.  if there are hairy topics, the should be last.  the vast majority of discussion of agenda items should have already taken place elsewhere, either on lists or in tickets.2) the meeting should actually stick to the agenda.  a meeting is really not a place to bring up random or tangential topics for discussion.  at most such things should be noted for further discussion and decision at future meetings, preferably during open floor.3) the chair of the meeting is responsible for keeping people on topic and completing the meeting in a timely manner.  be polite, but firm.4) if it is clear that a decision is not going to be reached on an item during the meeting, defer it for further discussion elsewhere.that's it.meetings should be focused with clear goals.  fedora meetings taking place on irc necessitates some amount of leeway because of the medium, but that does not mean meetings exist for the sake of meetings or for chat time.  irc is also a terrible place to have in-depth discussions on things, as people feel time pressured and the format of the dialogue can be difficult to follow.  so yes, my fesco meetings (or any other that i chair) tend to be shorter than most.  this is simply because i want the meeting to be productive and i don't want to waste people's time.  and if you feel that i am wrong on several points here, that is totally fine with me.  just volunteer to chair the meeting next time ;).

linkpost comment
















lpc 2015 day 2
[aug. 24th, 2015|03:10 pm]
jwboyer




i started day 2 of lpc with the graphics, mode setting, and wayland microconference.  this was an extremely dense microconference with lots of information on what is missing in various areas and what has been in the works for some time.  to be honest, i felt out of my depth several times.  however, it was very clear that the participants in the session were making good progress.  one side-note: nobody likes to use mics :).the afternoon session was heavy in hallway track for me.  i had some conversations with josef bacik around btrfs and fedora (summary: not yet).  i also spoke with him and another engineer from facebook around how they handle the kernel across their various machines.  it was an interesting high level look at what a company is doing at that scale.i also touched base with matthew garrett on the secure boot patchset.  this has been something that we've carried in fedora since around fedora 18.  it hasn't really changed much at all, but the patches have failed to get upstreamed for a number of trivial reasons.  there are a few follow-ups that need to be looked into as well though.  matthew plans on submitting them upstream again and i'm going to see what i can do to help them get merged.  hopefully the third (fourth?) time is a charm.the remainder of the afternoon was spent catching up with some old colleagues and meeting a few new people from various companies.  conversation was wide ranging.  we touched on technical topics as well as completely irrelevant things.  however, i think the time was very well spent as one of the major purposes of conferences is to meet up with people face to face.  without that interaction, it is too easy to resolve a person to nothing more than an email address and that never works out well.the evening event was held at rock bottom brewery and it was delicious.  we had some impromptu fedora kernel team time over dinner and shared dessert.  once all the ice cream and brownie was gone, i turned in shockingly early.  apparently the jet lag and two late nights in a row were starting to wear on me.

linkpost comment





lpc 2015 day 1
[aug. 21st, 2015|12:00 pm]
jwboyer




i have the privilege of attending the linux plumbers conference in seattle this week.  this is by far my favorite conference.  the talks and microconferences are all of high quality and the events are very well organized.the first day is shared with linuxcon, which lends itself to some talks that span both audiences.  the first talk i attended with "everything is a file descriptor" by josh triplett.  josh gave a great overview of why file descriptors are a great mechanism and some of the more recent system calls that have been added to give userspace the ability to write less crappy code.  things like timerfd, and signalfd allow userspace to avoid some of the awkwardness that comes with using the more traditional interfaces that unix has provided.  he also described work on clonefd, which is a new system call to allow userspace to get a file descriptor tied to a task in the kernel.  this will have some interested benefits, such as being able to pass the fd to a process that is not in your process hierarchy and being able to poll for child/task exit without hanging in waitpid.  at the end josh threw out some possible future additions that haven't been implemented.  overall a very well done talk.following that, i sat in on steven rostedt's talk on the rt patchset.  i've seen this talk or a version of it around three times and i'm always highly entertained.  steven likes to pack a ton of information in his talks.  the overall success of the rt patchset has been very good, and they are down to some of the final really hard bits.  some of them they actually need help with to figure out the best solution in the subsystem in question (like the vfs).  one of the questions from the audience was about lessons learned working on the patchset, the issues they've fixed in mainline because of it, etc.  steven said that is a great idea for another talk, so i hope he writes that up.  i would love to hear it.the afternoon session started off with an overview of acpi and where some of the acpi 6 features are coming into play.  things like low power idle and other pm related features look to be headed towards us in hardware, and acpi is of course being adapted to work with this.  overall a good overview.following that i did a bit of hallway track and then went to daniel vetter's talk on screwing up (or how to not) ioctls.  working in the drm layer has provided him with lots of experience over the past few years on how to properly design your code to make it easier to use.  one of the main points that was stressed several times was having testcases for everything.  this is fairly obvious, but he pointed out that the testcases are better written when you aren't looking at the code.  if you just look at the data structures and create boundary cases based on that, with all kinds of crazy input, you will often catch cases that the code itself doesn't cover.  he had a good amount to say and it was entertaining.the traditional kernel panel was the wrap up for the day, but i skipped that to catch up on some work.  then it was off to the evening event at the experience music project museum.  this venue was amazing and had a variety of exhibits ranging from a guitar collection to star wars costumes.  it was very cool and the food was excellent.  after spending perhaps a bit more than i expected in the gift shop, it was back to the hotel to try and sleep off some of the weariness that comes from travel delays and cramming information into your head all day.

linkpost comment















navigation





[
viewing
|
most recent entries
]


[
go
|
earlier
]



































